# -*- coding: utf-8 -*-
"""ComputeReward.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i1LXWAln-XzFHieP5nF1E6gBxa34jst7
"""

import numpy as np
import pandas as pd
import heapq

# ---------- Helper Functions (as defined before) ----------
def golden_section_search(f, a, b, tol=1e-5):
    invphi = (np.sqrt(5) - 1) / 2
    invphi2 = (3 - np.sqrt(5)) / 2
    h = b - a
    if h <= tol:
        return (a + b) / 2
    n = int(np.ceil(np.log(tol / h) / np.log(invphi)))
    c = a + invphi2 * h
    d = a + invphi * h
    yc, yd = f(c), f(d)
    for _ in range(n):
        if yc < yd:
            b, d, yd = d, c, yc
            h = invphi * h
            c = a + invphi2 * h
            yc = f(c)
        else:
            a, c, yc = c, d, yd
            h = invphi * h
            d = a + invphi * h
            yd = f(d)
    return (a + b) / 2

def all_or_nothing(n_nodes, links, costs, od_matrix, disrupted):
    adj = {i: [] for i in range(1, n_nodes+1)}
    for idx, (u, v, cap, t0) in enumerate(links):
        if idx in disrupted:
            continue
        adj[u].append((v, costs[idx], idx))
    flows = np.zeros(len(links))
    for i in range(1, n_nodes+1):
        dist = {node: np.inf for node in adj}
        prev = {}
        dist[i] = 0
        heap = [(0, i)]
        while heap:
            du, u = heapq.heappop(heap)
            if du > dist[u]:
                continue
            for v, w, idx in adj[u]:
                dv = du + w
                if dv < dist[v]:
                    dist[v] = dv
                    prev[v] = (u, idx)
                    heapq.heappush(heap, (dv, v))
        for j in range(1, n_nodes+1):
            d = od_matrix[i-1, j-1]
            if d <= 0 or (j not in prev and i != j):
                continue
            node = j
            while node != i:
                u, idx = prev[node]
                flows[idx] += d
                node = u
    return flows

def compute_ue_travel_time(n_nodes, links_df, od_matrix, disrupted_links,
                           alpha=0.15, beta=4, max_iter=100, tol=1e-4):
    links = list(zip(
        links_df['from'].astype(int),
        links_df['to'].astype(int),
        links_df['capacity'].astype(float),
        links_df['t0'].astype(float)
    ))
    K = links_df['capacity'].values
    t0 = links_df['t0'].values
    x = all_or_nothing(n_nodes, links, t0, od_matrix, set(disrupted_links))
    for it in range(max_iter):
        costs = t0 * (1 + alpha * (x / K)**beta)
        y = all_or_nothing(n_nodes, links, costs, od_matrix, set(disrupted_links))
        d = y - x
        def obj(lmbda):
            xt = x + lmbda * d
            return np.sum(t0 * xt * (1 + alpha * (xt / K)**beta))
        lam = golden_section_search(obj, 0, 1)
        x_new = x + lam * d
        gap = np.sum((y - x) * costs)
        if gap / np.sum(y * costs) < tol:
            x = x_new
            break
        x = x_new
    return np.sum(x * t0 * (1 + alpha * (x / K)**beta))

# ---------- Load SiouxFalls Network ----------
netfile = 'SiouxFalls_net.tntp'
lines = open(netfile).read().splitlines()
start = 0
for idx, line in enumerate(lines):
    if line.strip().startswith('~') and 'init_node' in line.lower():
        start = idx + 1
        break
data = []
for line in lines[start:]:
    if not line.strip() or line.startswith('<') or line.strip().startswith('~'):
        continue
    clean = line.strip().rstrip(';').strip()
    parts = clean.split()
    if len(parts) < 10:
        continue
    data.append(parts)
cols = ['init_node','term_node','capacity','length','free_flow_time','b','power','speed','toll','link_type']
net_df = pd.DataFrame(data, columns=cols)
net_df = net_df.astype({'init_node':int,'term_node':int,'capacity':float,'length':float,'free_flow_time':float,'b':float,'power':float,'speed':float,'toll':float,'link_type':int})
links_df = net_df.rename(columns={'init_node':'from','term_node':'to','free_flow_time':'t0'})

# ---------- Load SiouxFalls OD ----------
trips_file = 'SiouxFalls_trips.tntp'
lines = open(trips_file).read().splitlines()
start = 0
for idx, line in enumerate(lines):
    if '<END OF METADATA>' in line:
        start = idx + 1
        break
zones = 24
od_matrix = np.zeros((zones, zones))
current_origin = None
for line in lines[start:]:
    line = line.strip()
    if line.startswith('Origin'):
        parts = line.split()
        current_origin = int(parts[1])
    elif ':' in line:
        entries = line.rstrip(';').split(';')
        for ent in entries:
            ent = ent.strip()
            if not ent: continue
            dest, flow = ent.split(':')
            od_matrix[current_origin-1, int(dest)-1] = float(flow)

# ---------- Test UE Function ----------
# Baseline: no disruptions
tt_baseline = compute_ue_travel_time(24, links_df[['from','to','capacity','t0']], od_matrix, [])
print(f"Baseline total travel time (no disruptions): {tt_baseline:.2f}")

# Single link disrupted: e.g., link index 0
tt_disrupted = compute_ue_travel_time(24, links_df[['from','to','capacity','t0']], od_matrix, [0])
print(f"Total travel time with link 0 disrupted: {tt_disrupted:.2f}")